// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.7;

import { VRFConsumerBaseV2Plus } from '@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol';
import { VRFV2PlusClient } from '@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol';
import '@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol';

// 创建一个彩票合约
// 挑选一个随机数（这个随机数可被验证）
// 每隔 x 分钟挑选出一个 winner，

error Raffle_NotEnoughEth();
error Raffle_TransferFailed();
error Raffle_NotOpen();
error Raffle_NotNeeded(uint256 currentBalance, uint256 numPlayers, uint256 raffleState);

contract Raffle is VRFConsumerBaseV2Plus, AutomationCompatibleInterface {
    enum RaffleState {
        OPEN,
        PENDING
    } /** 被计算时，OPEN == 0，PENDINGz == 1 */

    /**
     * @dev 参与抽奖的最低金额
     */
    uint256 private immutable i_entranceFee;
    address payable[] private s_players;
    address private s_recentWinner;

    /**
     * @dev Chainlink VRF Coordinator 地址: 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625
     */
    // VRFCoordinatorV2Interface private immutable i_vrfCoordinator;
    /**
     * @dev 500 gwei Key Hash: 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae
     */
    bytes32 private immutable i_gasLane;
    uint256 private immutable i_subId;
    /**
     * @dev Minimum Confirmations 最小确认块数 : 3 （数字大安全性高，一般填12）
     */
    uint16 private constant REQUEST_COMFIRMATIONS = 3;
    /**
     * @dev callbackGasLimit gas限制 : 最大 2,500,000
     */
    uint32 private immutable i_callbackGasLimit;
    /**
     * @dev Maximum Random Values 一次可以得到的随机数个数 : 最大 500
     */
    uint32 private constant NUM_WORDS = 1;
    /**
     * @dev 当彩票正在挑选 winner 时，s_raffleState 应该置为 PENDING，此时不允许 player 再参与
     */
    RaffleState private s_raffleState;
    /**
     * @dev 上次抽奖的时间
     */
    uint256 private s_lastTimestamp;
    /**
     * @dev 抽奖的时间间隔
     */
    uint256 private immutable i_interval;
    /**
     * @dev true 则 chainlink VRF 在 fulfillRandomWords 时使用 LINK 来扣费，false 则使用 ETH 扣费
     */
    bool private immutable i_nativePayment;


    /** events */
    /**
     * 记录谁参与了抽奖
     */
    event RaffleEnter(address indexed player);
    /**
     * 记录发起的 requestRandomWords() 请求返回的 requestId
     */
    event RequestRaffleWinner(uint256 indexed requestId);
    /**
     * 记录最近挑选的 winner
     */
    event WinnerPicked(address indexed winner);

    constructor(
        address vrfCoordinatorAddr,
        uint256 entranceFee,
        bytes32 gasLane,
        uint256 subId,
        uint32 callbackGasLimit,
        uint256 interval,
        bool nativePayment
    ) VRFConsumerBaseV2Plus(vrfCoordinatorAddr) {
        i_entranceFee = entranceFee;
        i_gasLane = gasLane;
        i_subId = subId;
        i_callbackGasLimit = callbackGasLimit;
        s_raffleState = RaffleState.OPEN;
        // 使用区块链的时间作为起始时间
        s_lastTimestamp = block.timestamp;
        i_interval = interval;
        i_nativePayment = nativePayment;
    }

    function enterRaffle() public payable {
        if (msg.value < i_entranceFee) {
            revert Raffle_NotEnoughEth();
        }
        if (s_raffleState != RaffleState.OPEN) {
            revert Raffle_NotOpen();
        }
        s_players.push(payable(msg.sender));
        emit RaffleEnter(msg.sender);
    }

    /**
     * calldata 是Solidity 合约中的一个特殊的只读数据区域，用于存储函数调用的参数和外部合约的调用数据。 它适用于接收函数调用的输入数据，但不支持修改
     * 这个函数会被 chainlink automation 调用
     * @return upkeepNeeded
     * @return performData
     */
    function checkUpkeep(bytes memory /**checkData*/) public view override returns (bool upkeepNeeded, bytes memory /**performData*/) {
        // 1. 时间间隔达到阈值；2. 彩票至少有一个 player；3. 彩票的状态是 OPEN，满足这些要求后返回 true
        bool isOpen = (s_raffleState == RaffleState.OPEN);
        bool timePassed = ((block.timestamp - s_lastTimestamp) > i_interval);
        bool hasPlayers = (s_players.length > 0);
        bool hasBalance = (address(this).balance > 0);
        upkeepNeeded = (isOpen && timePassed && hasPlayers && hasBalance);
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        (bool upkeepNeeded, ) = checkUpkeep('');
        if (!upkeepNeeded) {
            revert Raffle_NotNeeded(address(this).balance, s_players.length, uint256(s_raffleState));
        }
        pickRandomWinner();
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    /**
     * 只能被其他合约调用，不能在当前合约内部直接调用
     * 获取随机数，使用 chainlink VRF
     */

    function pickRandomWinner() internal {
        /**
         * 使用chainlink VRF，构造函数需要继承 VRFConsumerBaseV2
         * 不同链参数填的不一样
         * 具体可以看：https://docs.chain.link/vrf/v2-5/getting-started
         * 网络: Sepolia测试网
         */
        // 将状态置为 PENDING，此时不允许其他观众再参与
        s_raffleState = RaffleState.PENDING;
        uint256 requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: i_gasLane,
                subId: i_subId,
                requestConfirmations: REQUEST_COMFIRMATIONS,
                callbackGasLimit: i_callbackGasLimit,
                numWords: NUM_WORDS,
                extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({ nativePayment: i_nativePayment }))
            })
        );
        emit RequestRaffleWinner(requestId);
    }

    function fulfillRandomWords(uint256 /* requestId */, uint256[] calldata randomWords) internal override {
        s_raffleState = RaffleState.OPEN;
        uint256 idx = randomWords[0] % s_players.length;
        address payable recentWinner = s_players[idx];
        s_recentWinner = recentWinner;
        s_players = new address payable[](0);
        s_lastTimestamp = block.timestamp;
        (bool success, ) = recentWinner.call{ value: address(this).balance }('');
        if (!success) {
            revert Raffle_TransferFailed();
        }
        emit WinnerPicked(recentWinner);
    }

    function getEntranceFee() public view returns (uint256) {
        return i_entranceFee;
    }

    function getPlayer(uint256 idx) public view returns (address) {
        return s_players[idx];
    }

    function getRecentWinner() public view returns (address) {
        return s_recentWinner;
    }

    function getRaffleState() public view returns (RaffleState) {
        return s_raffleState;
    }

    /**
     * 因为 NUM_WORDS 是常量，所以返回的可以是 pure
     */
    function getNumWords() public pure returns (uint32) {
        return NUM_WORDS;
    }

    function getNumberOfPlayers() public view returns (uint256) {
        return s_players.length;
    }

    function getLatestTimestamp() public view returns (uint256) {
        return s_lastTimestamp;
    }

    function getInterval() public view returns (uint256) {
        return i_interval;
    }

    function getRandom() public pure returns (uint64) {
        return 1;
    }
}
